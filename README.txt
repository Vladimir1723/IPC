

межпроцессные взаимодействия

системный вызов pid_t fork() - "вилка"
служит для порождения процессов

есть процесс parent, он исполняется и в какой-то момент достигает
fork(), ось в этот момент создает child(), который выполняется
с самого места вызова fork()

каждому процессу присваивается свой pid

fork-бомба - плодит pid'ы, пока они не кончатся и система станет
неработоспособной

вызов fork для child и для parent возвращает разные значения

для родителя возвращает child pid,
для ребенка: 0

при запуске системы есть процесс init, ктороый начинает вызывать
fork и плодить процессы
получается дерево процессов
у каждого есть свой pid
его можно получить вызывая getpid()

getppid() // parent pid - получить pid родителя

зачем такой неэффективный способ порождения процессов?
ведь получается очень много копирования
есть мех-м copy_on_write, он позволяет не копирровать пока не просят

пусть есть пр-сс с 8-ю ячейками памяти
8
7
6	- и тд.			- 	переменные
5	- стек
4	- куча
3 - код	и конст.    -
2 - код	и константы.-	- не меняются
1 - код и конст.    -


и есть физ. ячейки ram и установлено соответствие
1, 2, 3 можно ram может читать, остальные r/w

так живет этот процесс до вызова fork()
после него у нас появляется двойничок:


8
7
6
5
4
3
2
1

но этот процесс имеет везде доступ только на чтение (изначально)
=> пока мы не пытаемся что-то записывать, все чудесно, процесс живет со старой
памятью и физически копировать ее не нужно

однако настало время,когда процесс просится на запись в ячейку 8
=> ось копирует ячейку в ram

только на момент записи ось копирует ячейки, а те, куда ничего не
записывается, и не копируются - copy_on_write

этот мех-м позволяет сделать fork() очень эффективным средством порождения
процессов

константы и исходный код никогда не копируются (1, 2, 3)
 - пока не заменим исходный код вызовом access(), хехехе

перейдем к замене 1, 2, 3 - сегмента кода
как выполнить новый процесс?

int execl(const char* path, const char* arg...);
int execv(const char* path, char* const argv[]);
int execle(const char* path, const char* arg, ...., char* const envp[]);
int execve(const char* path, char* const argv[], char* const envp[]);
int execlp(const char* file, const char* arg...);
int execvp(const char* file, char* const argv[]);

где l - list, v - vector, e - environment (переменные окружения) -
 - задаются массивом char* const envp[]

extern char** environ;
	имя = значение
	.
	.
	.
	\0

	getenv, putenv, setenv, unsetenv

атрибуты процессов

pid, ppid мы уже знаем

процесс init имеет pid = 1

есть родитель с pid 122 и ppid 121
и ребенок с pid 123 и ppid 122

родитель умер.

где-то есть init с pid = 1.
дочерний процесс потерял родителя и => его ppid = 1, т.е.
он стал потомком init

есть переменные окружения, идентификаторы пользователя и группы
(реальные(кто создал uid_t getuid() uid_t getgid() + set'ы)
и эффективные (под чьими правами выполняется uid_t geteuid(), uid_t getegid()
то же с set'ами))

корневой и рабочий каталоги тоже атрибуты процесса

/var/www/aaa/index.html
корневой каталог это '/'

но root может это изменить в целях безопасности
мы можем сделать любой подкаталок корневым, а все что вне его - исчезнет
из области видимости и никогда не вернется
н-р сделать /var/www/ корневым каталогом

зачем? допустим, мы пишем веб-сервер и не сильно хотим,
чтобы злоумышленники смогли получить с его помощью получить что-то для них
не предназначенное
ограничиваем права
/var/www/ можно смотреть

но open("../../etc/passwd); выполнить уже нельзя, потому что у нас
корневой каталог и из него наверх выйти уже нельзя
(хотя воровать passwd уже не актуально)

рабочий каталог - тот, из которого запустили программу

корневой каталог может изменить только root
рабочий каталог - тот, кто выполняет программу

корневой каталог меняется через chroot("...");
рабочий chdir("..");
fchdir(fd);

приоритет процесса

насколько много процессорного времени получает процесс относительно соседей

N = [0,39]

если мы не root, то можем только уменьшить приоритет, root же
может его увеличить

ф-ия вежливости уменьшает приоритет
int nice (int decr); // root может подать на вход отрицательное число,
и тогда приоритет увеличится

nice возвр. тек приоритет процесса = [-20, 19] (N - 20)
такое вот legacy, исторически сложилось

есть один баг -
-1 	- валидный приоритет, однако при ошибке nice также вернет -1

ограничения (лимиты на разные параметры) 
getrlimit
setrlimit
 
ограничить можно по памяти, числу открытых дескрипторов, размеру
core dump файла (если программа по каким-либо причинам падает,
она откладывает на диске файл дамп-памяти core-dump файл, и делает она так
только если файл удовл. каким-либо условиям (размер, к примеру) )

сигнал - сообщение о наступлении события, он может быть послан другим процессом,
а может ядром оси

процесс А
-> signal
процесс В

ядро
-> signal
процесс В

первая стадия - генерация сигнала, затем ожидание доставки, затем доставка

опасность сигналов
есть приложение, читающее много данных из сокета командой
-recv()
-сюда приходит сигнал
- recv() прерывается и возвращает -1, errno = EINTR (interrupted - прервано)
- значит, нужно читать снова
вывод:	если используются блокирующий сокет, то не recv не явл.
гарантированно безопасной, recv можно прервать любым сигналом любого приложения

так что с любыми сокетами лучше работать в неблок. режиме

теперь поговорим о стадии "доставка"
как только сигнал пришел, есть несколько сценириев развития:
1) обработчик по умолчанию (есть зараннее заведенное действие, выполняющееся
по приходу сигнала)	SIG_DFL
2) SIG_IGN
3) свой обработчик

сигналы Ошибок
SIGFPE - ошибка в арифметике (деление на 0)
SIGPIPE - если пишем в разорванный сокет или разорванный pipe
чтоб его не было, есть константа MSG_NOSIGNAL в send или recv
SIGSEGV - сегментация
SIGXCPU - setrlimit/getrlimit по истечению лимита процессорного времени
вылезет этот сигнал
Генерируемый пользователем/приложением:
SIGABRT - вызов abort()
SIGHUP - разрыв связи с терминалом, модемом,
		если приложение получило SIGHUP, то оно должно прочитать
		конфиг. файл и перенастроиться.
		Если мы хотим перенастроить приложение не закрывая его, мы берем конфиг.
		файл и руками посылаем SIGHUP приложению
SIGKILL - сигнал №9, "убить девяткой", его нельзя перехватить, можно послать,
если у нас достаточно прав, то приложение умрет. Если приложение получило такой
сигнал, то оно в любом случае умрет и нельзя предпринять никаких действий в
попытке обработать SIGKILL
SIGTERM - terminate, по контракту, мы обязаны завершиться корректно, получив
этот сигнал (в отличие от SIGKILL)
его можно перехватить и даже отказаться завершаться (но не стоит, ведь
подразумевается, что мы закроем все файлы, сбросим весь кэш на диск,
запишем все логи и только потом завершимся)
SIGINT - interrupt (Ctrl + C) - прерывание с клавиатуры

сигналы, генер. пользователем, не имеют заранее никакой определенной логики,
никакого контракта и мы не знаем, как с ними действовать
SIGUSR1
SIGUSR2

сигналы управления задачами
SIGCHILD - умер потомок
	(получение exit-code)
	избавление от зомби

SIGSTOP
SIGCONTINUE

события таймера
alarm(...//число секунд//);
- приходит сигнал SIGALRM
SIGWTALRM // от виртуального таймера
SIGPROF // от профилирующего



ANSI-сигналы
#include <signal.h>

void (*signal(int signum,
			  void (*act)(int)
			  ))(int);

ф-ия имеет 2 арг-та
1 - signum (н-р SIGINT)
2 - void (*act)(int) -	ук-ль на обработчик сигнала

обраб:
void handler (int signim)	{
	...
}
есть и два станд. обраб SIG_DFL, SIG_IGN


возвращает ф-ия старый обработчик или SIG_ERR (тогда надо смотреть в errno)
есть 2 больших минуса исп. д. подхода (в новом коде рекомендуется таки писать
POSIX-сигналы, а не ANSI)
1) после вызова handler сигнал сбрасывается и устанавливается SIG_DFL
то есть всякий раз придется вызывать сигнал и
устанавливать обработчик заново 
2)обработка не блокируется приемом новых сигналов и может
прерваться

POSIX-сигналы

маска сигналов на каждый процесс служит для того, чтобы мы могли временно
заблокировать исполнение handler у какого-то сигнала

для постоянной блокировки сгодится и SIGIGN, а для временной нужна маска

sigset_t - тип
sigemptyset // - заполнение нулями
sigfillset // - 1
sigaddset // добавить сигнал
sigdelset // удалить
sigismember // есть ли д. сиг. в маске

sigprocmask // - установить маску для д. процесса
		 (int how, const sigset_t* set, // маска
					sigset_t* old_set // старая маска вернеттся
					);

how:
SIG_BLOCK - объединение масок
SIG_UNBLOCK - объединение с инвертир. маской  (с отрицанием маски)
SIG_SETMASK - присваивание маски

маску можно установить и на поток

чтобы установить handler, нужен системный вызов
int sigaction (int signum,
			const struct sigaction* act,
			struct sigaction* old_act);

struct sigaction {
	void (*sa_handler)(int); // SIG_DFL, SIG_IGN....
	
	void (*sa_sigaction)(int, siginfo_t*, void*);
	sigset_t sa_mask;
	int sa_flags;
}

sa_flags:

SA_NODEFER - дело в тотм что когда вызывается handler через selection,
тот сигнал, для которого нужен handler, блокируется по умолчанию, что бы
ни было указано в маске. Для того, чтобы один и тот же сигнал мы дважды в
самом себе не обрабатывали, но при указании SA_NODEFER этого гарантировать
нельзя, если явно наш сигнал в маске не указан.
Это создано для совместимости с функцией signal

SA_RESETHAND - сбросить обработчик в defalut после исполнения
SA_RESTART - не прерывать исполнение системных вызовов (то есть случай с
блокирующим сокетом уже не страшен, после того, как сигнал пришел к приложению,
читающему что-либо, приложение обработает сигнал и после продолжит чтение



RTS
SA_SIGINFO - сигнал реального времени
недостаток обычных: если 2 одинаковых пришли и мы не успели обработать, то они
могут склеиться и визуально мы будем видеть лишь 1 сигнал, а не 2 и обраб. вызовется только один раз.
	сигнал не имеет приоритета. сигнал не может передать информацию.
	поэтому во спасение наше были созданы сигналы реального времени
они имеют приоритет, у них есть очередь (два сигнала слипнуться не
могут) и с ними можно передавать, пусть и немного, но данные (одно целое число
 =((  )

SA_SIGINFO

void rts_handler(int signum , siginfo_t* info,
		void* context  /*констект процесса*/);

typedef struct {
	int si_signal; // номер сигнала
	int si_errno; // errno ассоциированное с сигналом
	int si_code; // код сигнала (< 0 - послал другой процесс, > - ядро)
}

si_code:
SI_USER - kill, raise
SI_QUEUE - sigqueue
SI_TIMER - истекло время таймера (timer_settime)

SI_ASYNCIO - закончилась операция асинх. вв/выв
SI_MESGQ - пришло сообщение

если сигнал послан процессом, то нсть 2 поля -
pid_t	si_pid;
uid_t	si_uid;
.............
данные которые можно передавать с сигналом:

union signal si_value;

->	union signal {
		int sival_int;
		void* sival_ptr;
	}

что за номера сигналов RTS
SIGRTMIN - минимальное значение сигнала RTS
SIGRTMAX

для промежуточных значений констант нет, поэтому пишут: SIGRTMIN + 1
														SIGRTMAX - 2

и т.д.

всего их число = RTSIG_MAX - их ПО-КРАЙНЕЙ МЕРЕ столько

сигналы имеют приоритет и для сигналов RTS чем меньше их номер, тем выше
приоритет


Научились принимать.
Как отправить?

kill(pid_t pid, int signum);
pid > 0, процессу
pid < -1, группе процессов
pid = 0, текущей группе процессов
pid = -1, всем, кому не лень (кому имеем право)

отправить самому себе:
raise (int signum); // вызывается синхронно

abort(); // SIGABRT
 - от kill отличается тем, что она гарантирует, что приложение завершится после
 ее вызова. ее нельзя перехватить.

  - эти функции данные передавать не умеют

sigqueue(pid_t pid, int signum,
			const union sigval value);	// передать RTS-сигнал


есть ф-ии, позв. делать timeout, ожидать неск. сек.
sleep(s);
nanosleep, usleep

int pause(); // тормозит навечно (зачем?)

- если происходит системный вызов и в этот момент приходит сигнал,
то вызов прерывается
так можно закончить pause();
так что лучше сказать, что pause не делает паузу, а ожмдает сигнал

int sigwait (const sigset_t* set /* - набор сигналов, котрый мы ждем */,
			int* signum);

int sigwaitinfo (const sigset_t* set,
					siginfo_t* info);


процессы-зомби
ЗОМБИ!!!

есть процесс
pid: 123
ppid: 122

есть его потомок
pid: 124
ppid: 123

int main(int argc, char** argv)	{

	return 0;	// exit-code
}

прошло время и child умер, вернув exit-code (н-р 2)
этот процесс становится зомби до тех пор, пока мы не узнаем, с каким exit-code
он завершился. Он его хранит, чтобы вернуть его нам, когда мы спросим.
Он не заниает память, не тратит время, только хранит code, чтобы вернуть его
родителю, когда тот попросит.
В чем же проблема? Он занимает pid и мы не можем создать процесс с таким же
pid, потому что мы должны знать, что процесс с таким-то pid завершился с таким-то exit-code, поэтому в обязанности любого родителя входит узнавать exit-code
своих детей
иначе будем плодить зомби, будем плодить pid, которые рано или поздно закончатся
и тогда всему конец - мы не сможем породить ни один процесс.

как избавиться от зомби?
чиать exit-code с помощью waitpid(pid_t pid, /*какой pid ожидаем*/
									int* statusp, int option);

pid = -1 // любой

waitpid - блокирующий, он ждет exit-code
сделать его неблокирующим (пусть проверяет, нет ли зомби, а затем возвращает
управлениие) - int option = WNDHANG

есть более старая ф-ия: wait(&status) = waitpid(-1, &status, 0);
когда вызывать waitpid?

рекомендуется в обработчике сигнала SIGCHLD (не обязательно)

иногда можно в цикле где-нибудь вызывать и тп.



Межпроцессное взаимодействие по отношению к файловой системе (фс)
сами файлы уже межпроцессное взаимодействие -
один процесс поработал, записал что-то в файл, умер, через год другой процесс
может получить данные файла.

однако мы рассмотрим более критичную ситуацию - несколько процессов лезут в
файл одновременно

2 процесса хотят писать
3 хотят читать


пишут байт за байтом (получим месиво из байт, одновременно же)

LOCK_EX (эксклюзивная блокировка)- только 1 процесс владеет ресурсом

есть еще 3 процесса читателя (чтение в отличие от записи одновременно проводить
можно, защита нужна лишь от одновременного чтения и записи)

LOCK_SH - позволяет многим процессам владеть ресурсом, но при наличии shared lock эксклюзивную блокировку мы поставить не можем, и наоборот

=> никогда одновременно не будет двух процессов записи, не будет 1 запись и 1 чтения, зато может быть много читателей


есть ф-ия flock(fd, LOCK_SH /*LOCK_EX, LOCK_UN - убрать блокировку
	если хотим неблокирующий режим, то еще | LOCK_NB */)

в Unix есть способ экс. блокировки не привяз. к фд

есть фс, будем считать что какой-то ресурс заблокирован, когда на фс
сущ. файл с каким-либо именем. Файл сущ - блок сущ, файла нет, блок - снята.
Есть мех-м, позв. проверять, снимать, ставить блокировку гарантированно

н-р: БД в папке, если хотим залочить, пусть в папке созд. файл db.lock, и
пока этот файл есть, ни один процесс к бд досуп не получит. Когда процесс, уст.
блокировку (создавший файл), этот файл удаляет, остальные могут получить доступ

if(lock("filename")) //если залочили	{
	// какие-либо действия
	unlock("filename");
}	else // не залочили	 { 
	...
}


bool lock(const char* filename)	{
	int fd;
	if (fd = open(filename, O_WRONLY | O_CREATE | O_EXCL /*если файл сущ.
				то мы не создаем его и возвр. ошибку*/, 0 /* права доступа*/)
				== -1)	{
		return false;
	}
	close(fd);
	return true;
}

bool unlock(const char* filename)	{
	unlink(filename); // удаляет файл
	return true;
}


lseek(fd, . ,SEEK_SET); // установка позиции
lseek(fd, 0, SEEK_CUR); // получение
lseek64


каналы - ср-во межпроц. вз.
именованные - fifo
неименованные - pipes

pipes:

	int pipe(int fd[2]);

приложение вызвало pipe и ядро создало канал
fd[0], fd[1] - два дескриптора, указывают на концы трубки
fd[0]>==============>fd[1],
причем fd[0] доступен для записи fd[1] для чтения

вызвали fork, получили дубликат, и fd[0] с fd[1] связаны с той же трубкой

допустим, мы закрыли у первого приложения fd[0], а у второго fd[1],
- канал от 1 процесса к другому (односторонний, для обеих сторон придется таки
юзать 2 канала или двусторонний(сокет))

при одновременной записи несколькими процессами в pipe,
есть константа PIPE_BUF - столько данных один процесс может писать в pipe,
чтобы они прошли неделимо

who | sort | uniq | wc
 | - это и есть pipe
 | - связывает stdout предыдущей команды с stdin следующей
 то есть, текстовый вывод одной программы попадает на вход другой


(who)-stdout<===>stdin-(sort)-stdout<===>
stdin-(uniq)-stdout<===>stdin-(wc)-stdout		

int dup2(int old_fd, int new_fd/*конкретный фд, который хотим получить*/ );

stdin - 0
stdout - 1
stderr - 2

то есть 1 всегда связывается с 0. Как подменить 1 и 0 для стороннего приложения?
создадим pipe
можем сделать fork() получить чистое приложение с тремя дескрипторами 0,1,2 и
pipe
затем close(stdin);
dup2(fd[1], 0); // fd[1] копировался в 0, т.е. стал stdin
close(fd[1]);

int dup3(int old_fd, int new_fd, int flags /*O_CLOEXEC*/);
dup2(N,N) = N;



	exec			system
pipe + dup2

	FILE* popen(const char* command,
				const char* type);
				// "r" напр-р

	int pclose(FILE* stream);


именованный канал:
	файл на фс, явл. входной дверью к каналу

все каналы устроены одинаково, так что все  сказанное для неименованных,
верно и для именованных

fifo

int mkfifo(const char* path,
			mode_t rights); // н-р 0660

каналы однонаправлены
---> ====== ---->
в обе  стороны - два канала
	либо
сокет
---->			--->
	 (=========)
---->			<----

однако unix-сокет требует от нас создания файла на диске, а мы не хотим(

если не хотим, то можем сделать unix-сокет, не привязанный ни к какому файлу:

int socketpair (int d, /* domain PF_UNIX и только!*/
				int type,
				int protocol,
				int sv[2]);
// пара сокетов, связанных друг с другом




Процессор
8 ножек 2 ручки для переноски
4 ядра
на нем запущено приложение, которое считает что-то, приходящее по сети,
и ответ отдает обратно в сеть
=> приложение слушает master-сокет, получает slave_socket и начинает его
исполнять
у нас 4 ядра, работаем в рамках 1 процесса и только с основным потоком
тогда загрузится только одно ядро. плохо
запустить 4 приложения?)
можно приложение расфоркать, получится, что один и тот же сокет слушаает
несколько приложений, и планировщик линукс сам распределит нагрузку
грязный метод, но работает
как сделать чисто? как контролировать распределение нагрузки на ядра процессора?

'плохая идея лишний раз гонять трафик по сокетам'

master и 4 worker'a
каждый воркер связывается с мастером через socketpair

master распределяет зарпросы через сокеты по воркерам
мастер читает запрос slave-сокета, пишет запрос в socketpair какому-нибудь
воркеру, тот его читает, исполняет, отвечает,
мастер читает, пишет в slave ответ и slave отправляет данные в сеть

сложна...
'плохая идея лишний раз гонять трафик по сокетам'

что если дескриптор slave'а мы могли бы передать воркерам, чтобы воркер
сам читал данные и отправлял обратно?

 - fd_passing
можно передать не только дескриптор сокета, но и файловый, да и вообще любой

теперь каждый воркер работает на своем ядре
можно даже привязать воркеров к ядрам жестко, но в этом, как правило, нет
необходимости - сколько воркеров, столько ядер -  планировщик сам разберется


size_t sock_fd_write(int sock, // сокет в который будем посылать
					void* buf, // информация котторую будем посылать
					ssize_t buflen, // размер информации
					int fd)	{ 
	ssize_t size;
	struct msghdr msg; // правильно заполняя эту структуру мы передадим
	// нашу порцию инфы со служебными  данными сд - наш дескриптор
	struct iovec iov; // сюда пишется наш буфер
	union { 
		struct cmsghdr ;
		char control[CMSG_SPACE(sizeof(int))];
	} cmsgu; 
	struct cmsghdr* cmsg;

	iov.iov_base = buf; iov.iov_len = buflen;
	// чтобы передать дескриптор, мы должны передать хотя бы 1 байт служебной ин	// фы = > buflen != 0
	msg.msg_name = NULL; msg.msg_namelen = 0;
	msg.msg_iov = &iov; msg.msg_iovlen = 1;

	if (fd != 1)	{
		msg.msg_control = cmsgu.control; // заполняется cmsgu
		msg.msg_controllen = sizeof(cmsgu.control);
		cmsg = CMSG_FIRSTHDR(&msg);
		cmsg->cmsg_len = CMSG_LEN(sizeof(int));
		cmsg->cmsg_level = SOL_SOCKET;
		cmsg->cmsg_type = SCM_RIGHTS;
		printf("passing fd %d\n", fd);
		*((int*)CMSG_DATA(cmsg)) = fd;
	}	else	{
		msg.msg_control = NULL;
		msg.msg_controllen = 0;
		printf("not passing fd\n");
	}
	size = sendmsg(sock, &msg, 0); /* sendto */
	if (size < 0)
		perror("sendmsg");
	return size;
}

теперь инфу нужно принять
ssize_t sock_fd_read (int sock, void* buf, ssize_t bufsize, int* fd)	{

	ssize_t size;
	if (fd)	{
		struct msghdr msg;
		struct iovec iov;
		union {
			struct cmsghdr;
			char control[XCMSG_SPACE(sizeof(int))];
		} cmsgu;
		struct cmsghdr* cmsg;

		// - те же переменные, те же объявления

		iov.iov_base = buf; // то же самое
		iov.iov_len = bufsize; // то же самое
		msg.msg_name = NULL; msg.msg_namelen = 0; msg.msg_iov = &iov;
		msg.msg_iovlen = 1;
		msg.msg_control = cmsgu.control;
		msg.msg_contollen = sizeof(cmsgu.contol);

		// - то же самое


		size = recvmsg(sock, &msg, 0);	// получили msg, теперь должны
		распарсить

		if (size cmsg_len ==
		CMSG_LEN(sizeof(int)) // != 0, если = 0, то ничего не пришло
		)	{
			if (cmsg->cmsg_level != SOL_SOCKET)
			{ // нам пришло то, что мы ожидали? 
				fprintf(srderr, "invalid cmsg_level %d\n",
					cmsg->cmsg_level); exit(1);
			}
			if (cmsg->cmsg_type != SCM_RIGTHS) { // аналогично
				fprintf(stderr, "invalid cmsg_type %d\n",
					cmsg->cmg_type); exit(1);
			}
			*fd = *((int*)CMSG_DATA(cmsg)); // достаем из DATA fd 
			printf("received fd %d\n", *fd); // пишем, что он пришел
		}	else *fd = 1;

	}
	else {

		size = read(sock, buf, bufsize);
		if (size < 0) { perror("read"); exit(1); }
	}

	return size;

}
